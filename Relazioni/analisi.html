  <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="./css/issStyle1.css">
        <!--<script type="text/javascript" src="../css/issStyle.js"></script>-->

        <title>Analisi preliminare</title>
    </head>

    <body>
        <div id="top">
            <h1>ANALISI PRELIMINARE<font size="5"></font> </h1>
        </div>

        <div class="body">
            <h2>Introduzione</h2>
            <p>Una stanza per <kc>Servizio buffet</kc> è equipaggiata con una serie di risorse (smart e non), inclusi
            un <em>frigo</em><tt> (Fridge)</tt>, una <em>lavastoviglie</em><tt> (Dishwasher)</tt>, una <em>dispensa</em><tt> (Pantry)</tt>,
            ed un ddr robot capace di lavorare come <em>Room Butler</em> (d'ora in poi chiamato <bc>RBR</bc> (<tt>Room Butter Robot</tt>)).</p>

            <p>Il <em>frigo</em>, la <em>lavastoviglie</em> e la <em>dispensa</em> sono incassati nei muri della stanza;
            sono, quindi, da escludere eventuali altre protuberanze dei muri.</p>

            <p>Al centro è posto un <em>tavolo</em>, in modo che la configurazione della stanza sia simile a quella della seguente figura:</p>

            <div style = "width:60%"><center><img src="./images/analisi/roomLayout.png" alt="roomLayout" width="75%" height="32%"/></center></div>

            L'andamento del <tt>Buffet</tt> è supervisionato da un <em>Maître de salle</em> (o più semplicemente <bc>Maitre</bc>)
            il quale dialoga con l'<bc>RBR</bc> per far eseguire una serie di task, inclusi:

            <ol>
            <li><i>Prepare the room</i>: consiste nel porre sul <em>tavolo</em> i piatti presi dalla
            <em>dispensa</em> e il cibo contenuto nel <em>frigo</em>. In questa fase, l'insieme degli elementi da porre sul tavolo sono fissi e descritti
            in maniera appropriata.</li>

            <li><i>Clear the room</i>: consiste nel riportare al <em>frigo</em> il cibo non consumato ed i piatti utilizzati alla <em>lavastoviglie</em>.</li>

            <li><i>Add food</i>: consiste nel portare dal <em>frigo</em> al <em>tavolo</em> un determinato cibo (se presente).
            </ol>

            Inoltre, il <em>frigo</em> viene considerato un device smart in grado di conoscere il proprio contenuto. Esso dovrebbe essere in grado
            (via <ks>CoAP</ks>) di rispondere a domande riguardanti il proprio contenuto, siano esse fatte da umani o macchine.

            <br/><br/>
            Al momento, <em>lavastoviglie</em> e <em>dispensa</em> non sono da intedere come strumenti smart.

            <h2>Requisiti</h2>
            <div class="req">
                <div>
                    Progettare ed implementare un software da installare su <em>frigo</em> e <bc>RBR</bc>. In particolare,
                    l'<bc>RBR</bc> deve essere in grado di accettare i seguenti comandi inviatogli via <ks>smart-phone</ks> dal <bc>Maitre</bc>:

                    <ul>
                    <li><em>prepare</em>: l'<bc>RBR</bc> de eseguire autonomamente il task <i>Prepare the room</i>.</li>
                    <li><em>add food</em>: l'<bc>RBR</bc> de eseguire autonomamente il task <i>Add food</i>.</li>
                    <li><em>clear</em>: l'<bc>RBR</bc> de eseguire autonomamente il task <i>Clear the room</i>.</li>
                    </ul>

                    Questi task devono essere eseguiti in sequenza. Un possibile scenario può essere il seguente:

                    <ol>
                    <li>All'inizio, la stanza è vuota, la <em>dispensa</em> e il <em>frigo</em> sono pieni. L'<bc>RBR</bc> è in <ks>RH</ks>
                    e la <em>lavastoviglie</em> è vuota.</li>
                    <li>Il <bc>Maitre</bc> invia al <bc>RBR</bc> il comando di <em>prepare</em> ed aspetta il completamento del relativo task.
                    At the end, the <bc>RBR</bc> is in its <ks>RH</ks> location again. </li>
                    <li>The <bc>Maitre</bc> opens the room to people. During the service, the <bc>Maitre</bc> can send to the <bc>RBR</bc>
                    the <em>add food</em> command, by specifying a <em>food-code</em>. The <bc>RBR</bc> executes the task only if food
                    with the given code is available in the <em>fridge</em>, otherwise it sends a warning to the <bc>Maitre</bc>. After the task completion,
                    the <bc>RBR</bc> returns is in its <ks>RH</ks> location.
                    </li>
                    <li>At the end of the party, the <bc>Maitre</bc> <bc>Maitre</bc> sends to the <bc>RBR</bc> the <em>clear</em> command
                    and waits for the completion of the task. The <bc>RBR</bc> returns is in its <ks>RH</ks> location again.
                    </ol>

                    However, the <bc>Maitre</bc> is able, at any time, to
                    use his/her smart-phone to:
                    <ul>
                    <li><em>consult</em> the <kc>state of the room</kc>, e.g. to known what are the objects related to each resource;
                    for example, the object currently posed on the <em>Table</em>, in the <em>dishwasher</em>, etc;</li>
                    <li><em>stop</em> or <em>reactivate</em> an activated task.</li>
                    </ul>

                    Finally, the <bc>RBR</bc> must be able to
                    <ul>
                    <li><em>avoid </em>the impact with mobile obstacles (e.g. the <bc>Maitre</bc>
                    or other humans / animals present in the room).</li>
                    </ul>

                    The software to put on the <em>fridge</em> should make the device able to:
                    <ul>
                    <li><em>expose</em> its current content on the <bc>Maitre</bc> smart-phone;</li>
                    <li><em>answer</em> to questions about its content (e.g. if it contains food with a given code ).</li>
                    </ul>
                </div>
            </div>

            <h2>Analisi dei requisiti</h2>
            <div>
                <ol>
                    <li>Il software è un sistema distribuito composto principalmente da tre entità: RBR, Maitre, Fridge.</li>
                    <li>Il software del Maitre deve poter essere acceduto da qualsiasi dispositivo, mobile o fisso.</li>
                    <li>L'RBR è stato definito tramite il documento <a href="">UsingRobot2019.pdf</a>.</li>
                    <li>Il Maitre deve essere in grado di inviare i comandi di prepare, add food e clear all'RBR.</li>
                    <li>L'RBR deve essere in grado di eseguire in maniera autonoma i tre task.</li>
                    <li>Il flusso di esecuzione del sistema deve essere, in sequenza: prepare, add food, clear.</li>
                    <li>L'RBR deve avere un punto di partenza e di arrivo di ogni task (Robot Home, RH).</li>
                    <li>Pantry, Fridge e Dishwasher hanno, ognuno, un contenuto iniziale valido.</li>
                    <li>Il Maitre deve essere in grado di aspettare il completamento del task richiesto.</li>
                    <li>Ogni cibo ha un food code associato, utile durante l'esecuzione del task add food.</li>
                    <li>L'RBR deve essere in grado di chiedere al frigo la presenza o meno di un determinato cibo.</li>
                    <li>L'RBR deve essere in grado di notificare con un allarme l'assenza di un preciso cibo nel frigo.</li>
                    <li>Il Maitre deve poter consultare in tempo reale lo stato della stanza in termini di contenuto del tavolo, della pantry, della dishwasher e del frigo-</li>
                    <li>Il Maitre deve poter fermare e riattivare il task attualmente in esecuzione-</li>
                    <li>L'RBR deve essere in grado di evitare eventuali ostacoli mobili.</li>
                    <li>Il frigo deve esporre il suo contenuto.</li>
                    <li>Il frigo deve poter rispondere a domande riguardo al suo contenuto. Non è ben definito quali siano queste domande, ad esempio, potrebbero
                        essere relative alla quantità di cibo presente.</li>
                    <li>Il fridge deve esporre un'interfaccia COAP</li>
                </ol>

                <h3>Test plan</h3>
                <div>
                    <ul>
                        <li>Se l'RBR riceve il comando <em>prepare</em> esso deve passare da uno stato di <em>idle</em> ad un stato <em>preparing</em>
                            che ne indichi l'avvenuta ricezione. Analogamente per gli altri task.</li>
                        <li>Se l'RBR riceve il comando di <em>stop</em> deve trovarsi in uno stato di <em>stopped</em>. Se riattivato con il comando
                        <em>reactivate</em> deve riportarsi nello stato precendente a quello di stop.</li>
                        <li>Se l'RBR ha terminato il task <i>Prepare the room</i> deve essere insensibile alla ricezione di altri comandi di <em>prepare</em>.
                        Deve poter cambiare di stato esclusivamente alla ricezione di un <em>add food</em> o di un <em>clear</em>.</li>
                        <li>Al termine delle operazioni, l'RBR deve sempre trovarsi nella posizione RH.</li>
                        <li>Se viene modificato il contenuto di Fridge, Dishwasher, Pantry o Table è necessario controllare che essi siano stati
                            effettivamente modificati</li>
                        <li>
                          ...
                        </li>
                    </ul>

                </div>
            </div>

            <h2>Analisi del problema</h2>
            <div>
                <ol>
                    <li>La natura distribuita del sistema porta a dover utilizzare l'infrastruttura QAK, presente nella software house di riferimento.
                    Essa ci permette di astrarre dai dettagli comunicativi consentendo, quindi, di concentrarsi sulla business logic
                    </li>
                    <li>
                    Il fatto che il robot debba poter operare su pantry, dishwasher, fridge e table porta a dire che si
                    debba creare una rappresentazione della stanza in cui lavorare nota al robot.
                    </li>
                    <li>La capacità del robot di poter evitare gli ostacoli implica che questo debba avere un
                    comportamento proattivo nei confronti dei comandi maitre e reattivo verso eventuali ostacoli che possono presentarsi
                    </li>
                    <li>
                      Il maitre deve essere reattivo a diverse informazioni contemporaneamente e nella gestione di queste rimanere
                      vigile sulle altre.
                    </li>
                    <li>
                      I requisiti relativi al fridge suggeriscono un tipo di interazione request-response che l'infrastruttura attualmente
                      non supporta
                    </li>
                    <li>
                      L'esecuzione del task clear suggerisce che il robot debba sapere cosa si trova in un certo istante sul tavolo
                    </li>
                    <li>
                      L'utilizzo dell'infrastruttura QAK non permette di creare ASF in cui uno stato è sia reattivo ad un messaggio sia
                      si porta in un nuovo stato tramite una transizione spontanea
                    </li>
                </ol>

                <div><center><img src="./images/analisi/Relazione_firstPrototype.png" alt="Relazione_firstPrototype" width="110%" height="50%"/></center></div>

                <h3>Comportamento Butler</h3>
                <div class="img" style="width:60%">
                  <center><img src="./images/analisi/Z0_ButlerBehaviour.png" alt="Z0_ButlerBehaviour" width="150%" height="50%"/></center>
                </div></br>

                <h3>Comportamento Maitre</h3>
                <div class="img" style="width:60%">
                  <center><img src="./images/analisi/Z0_MaitreBehaviour.png" alt="Z0_ButlerBehaviour" width="150%" height="50%"/></center>
                </div></br>

                <h3>Comportamento Fridge</h3>
                <div class="img" style="width:60%">
                  <center><img src="./images/analisi/Z0_FridgeBehaviour.png" alt="Z0_ButlerBehaviour" width="90%" height="50%"/></center>
                </div></br>

                <h3>Comportamento Pantry</h3>
                <div class="img" style="width:60%">
                  <center><img src="./images/analisi/Z0_PantryBehaviour.png" alt="Z0_ButlerBehaviour" width="90%" height="50%"/></center>
                </div></br>

                <h3>Comportamento Dishwasher</h3>
                <div class="img" style="width:60%">
                  <center><img src="./images/analisi/Z0_DishwasherBehaviour.png" alt="Z0_ButlerBehaviour" width="90%" height="50%"/></center>
                </div></br>

                <h3>Comportamento Table</h3>
                <div class="img" style="width:60%">
                  <center><img src="./images/analisi/Z0_TableBehaviour.png" alt="Z0_ButlerBehaviour" width="90%" height="50%"/></center>
                </div></br>
            </div>

            <h3>Review Test plan</h3>
            <div>
              Tutti i componenti sono modellati come automi a stati finiti, come tali i test dovrebbero essere in grado di stabili se effettivamente è avvenuta la transizione di stato desiderata.
              Al fine di fare questo potrebbe essere una buona idea:
              <ul>
                <li>
	                 Poter identificare univocamente uno stato
                </li>
                <li>
                   Poter accedere allo stato corrente di un componente
                </li>
              </ul>

              Questo è necessario per poter realizzare i test delineati precedentemente.
              Quanto detto suggerisce l'idea che debba essere associato un modello ad ogni componente che tenga
              traccia degli stati in cui si trova.
              Un buon modo di modellare queste informazioni è quello di usare dei file <em>Prolog</em> che oltre alla
              flessibilità e la potenza espressiva che si ha tramite l’unificazione permettono di modificare
              facilmente le varie voci presenti all’interno.
              Le informazioni di cui tenere traccia alla luce dei requisiti sono:</br>
              	MAITRE
                <ul>
                  <li>state(maitre,X)</li>
                  <li>task(maitre,X)</li>
                </ul>
              	PANTRY
                <ul>
                  <li>state(pantry,X)</li>
                  <li>dish(pantry,QNT)</li>
                </ul>
              	FRIDGE
                <ul>
                  <li>state(fridge,X)</li>
                  <li>food(fridge,FC,QNT)</li>
                </ul>
              	TABLE
                <ul>
                  <li>state(table,X)</li>
                  <li>dish(table,X)</li>
                  <li>food(table,FC,QNT)</li>
                </ul>
                DISHWASHER
                <ul>
                  <li>state(dishwasher,X)</li>
                  <li>dish(dishwasher,QNT)</li>
                </ul>
              	BUTLER
                <ul>
                  <li>state(butler,X)</li>
                  <li>task(butler,X)</li>
                  <li>position(butler,[X,Y])</li>
                  <li>onboardDish(butler,QNT)</li>
                  <li>onboardFood(butler,QNT)</li>
                </ul>

            </div>
            <h2>Project</h2>
            <div>
              Qui è stato principalmente strutturato il <em>refactoring MVC</em>, quindi quanto visto prima diventa:
              <div class="img" style="width:60%">
                <center><img src="./images/analisi/maitreArchitecture.png" alt="maitreArchitecture" width="90%" height="50%"/></center>
              </div></br>

              <div class="img" style="width:60%">
                <center><img src="./images/analisi/fridgeArchitecture.png" alt="fridgeArchitecture" width="90%" height="50%"/></center>
              </div></br>

              <div class="img" style="width:60%">
                <center><img src="./images/analisi/DishwasherModelButlerArchitecture.png" alt="DishwasherModelButlerArchitecture" width="90%" height="50%"/></center>
              </div></br>

              <div class="img" style="width:60%">
                <center><img src="./images/analisi/PantryModelButlerArchitecture.png" alt="PantryModelButlerArchitecture" width="90%" height="50%"/></center>
              </div></br>

              <div class="img" style="width:60%">
                <center><img src="./images/analisi/TableModelButlerArchitecture.png" alt="TableModelButlerArchitecture" width="90%" height="50%"/></center>
              </div></br>

              <div class="img" style="width:60%">
                <center><img src="./images/analisi/ButlerModelButlerArchitecture.png" alt="ButlerModelButlerArchitecture" width="90%" height="50%"/></center>
              </div></br>

              <div>
                In realtà per il butler la cosa è più articolata perchè a causa della complessità del sistema risulta essere utile
                adottare un procedimento model-driven e quindi subordinare i cambiamenti del sistema a cambiamenti del modello
                stesso. Ogni cambiamento produrrà un <em>Event</em> modelChange(NAME,ACTION) e solo chi sarà sensibile a questo tipo
                di informazioni farà scattare la propria logica di business 
              </div>
            </div>
            <h2>Test plans</h2>
            <p>I test sono stati sviluppati con JUnit</p>
            <div>
              <div class="img" style="width:60%">
                <center><img src="./images/analisi/testMenu.png" alt="testMenu" width="60%" height="50%"/></center>
              </div></br>
            </div>

            <h3>TestLogicButler</h3>
            <div>
              <div class="img" style="width:60%">
                <center><img src="./images/analisi/TestLogicButler.png" alt="TestLogicButler" width="100%" height="50%"/></center>
              </div></br>
            </div>

            <h3>TestLogicPantry</h3>
            <div>
              <div class="img" style="width:60%">
                <center><img src="./images/analisi/TestLogicPantry.png" alt="TestLogicPantry" width="100%" height="50%"/></center>
              </div></br>
            </div>

            <h3>TestMovementRobot</h3>
            <div>
              <div class="img" style="width:60%">
                <center><img src="./images/analisi/TestMovementRobot.png" alt="TestMovementRobot" width="100%" height="50%"/></center>
              </div></br>
            </div>

            <h3>TestObstacleDetection</h3>
            <div>
              <div class="img" style="width:60%">
                <center><img src="./images/analisi/TestObstacleDetection.png" alt="TestObstacleDetection" width="100%" height="50%"/></center>
              </div></br>
            </div>

            <h3>TestPositionRobot</h3>
            <div>
              <div class="img" style="width:60%">
                <center><img src="./images/analisi/TestPositionRobot.png" alt="TestPositionRobot" width="100%" height="50%"/></center>
              </div></br>
            </div>

        </div>



        <div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;font-size:small;color:white">
            Alessandro Calvio, email: alessandro.calvio@studio.unibo.it
            </br>
            Lorenzo Mustich, email: lorenzo.mustich@studio.unibo.it
        </div>
    </body>
</html>
