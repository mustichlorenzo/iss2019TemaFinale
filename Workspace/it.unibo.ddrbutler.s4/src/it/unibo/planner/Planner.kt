/* Generated by AN DISI Unibo */ 
package it.unibo.planner

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Planner ( name: String, scope: CoroutineScope ) : ActorBasicFsm( name, scope){
 	
	override fun getInitialState() : String{
		return "s0"
	}
		
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		
				var NextMove = ""
				var finito = false
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
						println("[PLANNER]: Started...")
					}
					 transition( edgeName="goto",targetState="waitCmd", cond=doswitch() )
				}	 
				state("waitCmd") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						if(finito){
									replyToCaller("planningCompleted","planningCompleted")
									finito=false
								}
					}
					 transition(edgeName="t065",targetState="calculatePath",cond=whenDispatch("goto"))
					transition(edgeName="t066",targetState="updateRoomDescription",cond=whenDispatch("setLocation"))
				}	 
				state("updateRoomDescription") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("setLocation(NAME,X,Y)"), Term.createTerm("setLocation(NAME,X,Y)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								solve("assert(location(${payloadArg(0)},${payloadArg(1)},${payloadArg(2)}))","") //set resVar	
								if(currentSolution.isSuccess()) { println("Posizione table salvata ${payloadArg(0)} ${payloadArg(1)} ${payloadArg(2)} ")
								 }
								else
								{ println("Errore salvataggio posizione table")
								 }
						}
					}
					 transition( edgeName="goto",targetState="waitCmd", cond=doswitch() )
				}	 
				state("calculatePath") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						storeCurrentMessageForReply()
						if( checkMsgContent( Term.createTerm("goto(X)"), Term.createTerm("goto(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								solve("location(${payloadArg(0)},X,Y)","") //set resVar	
								
												var cX=getCurSol("X").toString()
												var cY=getCurSol("Y").toString()
								println("Voglio andare in ${payloadArg(0)} ${getCurSol("X")} ${getCurSol("Y")}")
								itunibo.planner.moveUtils.setGoal(myself ,cX, cY )
								itunibo.planner.moveUtils.doPlan(myself)
								println("STORED!!")
						}
					}
					 transition( edgeName="goto",targetState="schedulingNextMove", cond=doswitch() )
				}	 
				state("schedulingNextMove") { //this:State
					action { //it:State
						
									finito=false
									NextMove=""
						solve("move(X)","") //set resVar	
						if(currentSolution.isSuccess()) { NextMove = getCurSol("X").toString()
						 }
						else
						{ finito=true
						 }
						stateTimer = TimerActor("timer_schedulingNextMove", 
							scope, context!!, "local_tout_planner_schedulingNextMove", 1000.toLong() )
					}
					 transition(edgeName="t067",targetState="checkFinish",cond=whenTimeout("local_tout_planner_schedulingNextMove"))   
					transition(edgeName="t068",targetState="schedulingStopped",cond=whenDispatch("stopTask"))
				}	 
				state("checkFinish") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
					}
					 transition( edgeName="goto",targetState="execMove", cond=doswitchGuarded({!finito}) )
					transition( edgeName="goto",targetState="waitCmd", cond=doswitchGuarded({! !finito}) )
				}	 
				state("schedulingStopped") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
					}
					 transition(edgeName="t069",targetState="execMove",cond=whenEventGuarded("reactivateTask",{!finito}))
					transition(edgeName="t070",targetState="waitCmd",cond=whenEventGuarded("reactivateTask",{finito}))
				}	 
				state("execMove") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						forward("movementCmd", "movementCmd($NextMove)" ,"movementhandler" ) 
						itunibo.planner.moveUtils.showCurrentRobotState(  )
					}
					 transition(edgeName="t071",targetState="confirmStep",cond=whenDispatch("moveCompleted"))
					transition(edgeName="t072",targetState="backward",cond=whenDispatch("moveFailed"))
				}	 
				state("confirmStep") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						itunibo.planner.moveUtils.doPlannedMove(myself ,NextMove )
						solve("retract(move(_))","") //set resVar	
						if(currentSolution.isSuccess()) { println("move cancelled")
						 }
						else
						{ println("move not cancelled")
						 }
						itunibo.planner.moveUtils.showCurrentRobotState(  )
					}
					 transition( edgeName="goto",targetState="schedulingNextMove", cond=doswitch() )
				}	 
				state("backward") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						forward("movementCmd", "movementCmd(s)" ,"movementhandler" ) 
					}
					 transition(edgeName="t073",targetState="waitObstacleToGo",cond=whenDispatch("moveCompleted"))
				}	 
				state("waitObstacleToGo") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						stateTimer = TimerActor("timer_waitObstacleToGo", 
							scope, context!!, "local_tout_planner_waitObstacleToGo", 1500.toLong() )
					}
					 transition(edgeName="t074",targetState="schedulingNextMove",cond=whenTimeout("local_tout_planner_waitObstacleToGo"))   
				}	 
			}
		}
}
